/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package imagepromoterfakes

import (
	"sync"

	promoter "sigs.k8s.io/promo-tools/v3/imagepromoter"
	inventory "sigs.k8s.io/promo-tools/v3/legacy/dockerregistry"
)

type FakePromoterImplementation struct {
	ActivateServiceAccountsStub        func(*promoter.Options) error
	activateServiceAccountsMutex       sync.RWMutex
	activateServiceAccountsArgsForCall []struct {
		arg1 *promoter.Options
	}
	activateServiceAccountsReturns struct {
		result1 error
	}
	activateServiceAccountsReturnsOnCall map[int]struct {
		result1 error
	}
	AppendManifestToSnapshotStub        func(*promoter.Options, []inventory.Manifest) ([]inventory.Manifest, error)
	appendManifestToSnapshotMutex       sync.RWMutex
	appendManifestToSnapshotArgsForCall []struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}
	appendManifestToSnapshotReturns struct {
		result1 []inventory.Manifest
		result2 error
	}
	appendManifestToSnapshotReturnsOnCall map[int]struct {
		result1 []inventory.Manifest
		result2 error
	}
	GetPromotionEdgesStub        func(*inventory.SyncContext, []inventory.Manifest) (map[inventory.PromotionEdge]interface{}, error)
	getPromotionEdgesMutex       sync.RWMutex
	getPromotionEdgesArgsForCall []struct {
		arg1 *inventory.SyncContext
		arg2 []inventory.Manifest
	}
	getPromotionEdgesReturns struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}
	getPromotionEdgesReturnsOnCall map[int]struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}
	GetRegistryImageInventoryStub        func(*promoter.Options, []inventory.Manifest) (inventory.RegInvImage, error)
	getRegistryImageInventoryMutex       sync.RWMutex
	getRegistryImageInventoryArgsForCall []struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}
	getRegistryImageInventoryReturns struct {
		result1 inventory.RegInvImage
		result2 error
	}
	getRegistryImageInventoryReturnsOnCall map[int]struct {
		result1 inventory.RegInvImage
		result2 error
	}
	GetSnapshotManifestsStub        func(*promoter.Options) ([]inventory.Manifest, error)
	getSnapshotManifestsMutex       sync.RWMutex
	getSnapshotManifestsArgsForCall []struct {
		arg1 *promoter.Options
	}
	getSnapshotManifestsReturns struct {
		result1 []inventory.Manifest
		result2 error
	}
	getSnapshotManifestsReturnsOnCall map[int]struct {
		result1 []inventory.Manifest
		result2 error
	}
	GetSnapshotSourceRegistryStub        func(*promoter.Options) (*inventory.RegistryContext, error)
	getSnapshotSourceRegistryMutex       sync.RWMutex
	getSnapshotSourceRegistryArgsForCall []struct {
		arg1 *promoter.Options
	}
	getSnapshotSourceRegistryReturns struct {
		result1 *inventory.RegistryContext
		result2 error
	}
	getSnapshotSourceRegistryReturnsOnCall map[int]struct {
		result1 *inventory.RegistryContext
		result2 error
	}
	MakeProducerFunctionStub        func(bool) promoter.StreamProducerFunc
	makeProducerFunctionMutex       sync.RWMutex
	makeProducerFunctionArgsForCall []struct {
		arg1 bool
	}
	makeProducerFunctionReturns struct {
		result1 promoter.StreamProducerFunc
	}
	makeProducerFunctionReturnsOnCall map[int]struct {
		result1 promoter.StreamProducerFunc
	}
	MakeSyncContextStub        func(*promoter.Options, []inventory.Manifest) (*inventory.SyncContext, error)
	makeSyncContextMutex       sync.RWMutex
	makeSyncContextArgsForCall []struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}
	makeSyncContextReturns struct {
		result1 *inventory.SyncContext
		result2 error
	}
	makeSyncContextReturnsOnCall map[int]struct {
		result1 *inventory.SyncContext
		result2 error
	}
	ParseManifestsStub        func(*promoter.Options) ([]inventory.Manifest, error)
	parseManifestsMutex       sync.RWMutex
	parseManifestsArgsForCall []struct {
		arg1 *promoter.Options
	}
	parseManifestsReturns struct {
		result1 []inventory.Manifest
		result2 error
	}
	parseManifestsReturnsOnCall map[int]struct {
		result1 []inventory.Manifest
		result2 error
	}
	PrecheckAndExitStub        func(*promoter.Options, []inventory.Manifest) error
	precheckAndExitMutex       sync.RWMutex
	precheckAndExitArgsForCall []struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}
	precheckAndExitReturns struct {
		result1 error
	}
	precheckAndExitReturnsOnCall map[int]struct {
		result1 error
	}
	PromoteImagesStub        func(*inventory.SyncContext, map[inventory.PromotionEdge]interface{}, promoter.StreamProducerFunc) error
	promoteImagesMutex       sync.RWMutex
	promoteImagesArgsForCall []struct {
		arg1 *inventory.SyncContext
		arg2 map[inventory.PromotionEdge]interface{}
		arg3 promoter.StreamProducerFunc
	}
	promoteImagesReturns struct {
		result1 error
	}
	promoteImagesReturnsOnCall map[int]struct {
		result1 error
	}
	ScanEdgesStub        func(*promoter.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error
	scanEdgesMutex       sync.RWMutex
	scanEdgesArgsForCall []struct {
		arg1 *promoter.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}
	scanEdgesReturns struct {
		result1 error
	}
	scanEdgesReturnsOnCall map[int]struct {
		result1 error
	}
	SnapshotStub        func(*promoter.Options, inventory.RegInvImage) error
	snapshotMutex       sync.RWMutex
	snapshotArgsForCall []struct {
		arg1 *promoter.Options
		arg2 inventory.RegInvImage
	}
	snapshotReturns struct {
		result1 error
	}
	snapshotReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateManifestListsStub        func(*promoter.Options) error
	validateManifestListsMutex       sync.RWMutex
	validateManifestListsArgsForCall []struct {
		arg1 *promoter.Options
	}
	validateManifestListsReturns struct {
		result1 error
	}
	validateManifestListsReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateOptionsStub        func(*promoter.Options) error
	validateOptionsMutex       sync.RWMutex
	validateOptionsArgsForCall []struct {
		arg1 *promoter.Options
	}
	validateOptionsReturns struct {
		result1 error
	}
	validateOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePromoterImplementation) ActivateServiceAccounts(arg1 *promoter.Options) error {
	fake.activateServiceAccountsMutex.Lock()
	ret, specificReturn := fake.activateServiceAccountsReturnsOnCall[len(fake.activateServiceAccountsArgsForCall)]
	fake.activateServiceAccountsArgsForCall = append(fake.activateServiceAccountsArgsForCall, struct {
		arg1 *promoter.Options
	}{arg1})
	stub := fake.ActivateServiceAccountsStub
	fakeReturns := fake.activateServiceAccountsReturns
	fake.recordInvocation("ActivateServiceAccounts", []interface{}{arg1})
	fake.activateServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsCallCount() int {
	fake.activateServiceAccountsMutex.RLock()
	defer fake.activateServiceAccountsMutex.RUnlock()
	return len(fake.activateServiceAccountsArgsForCall)
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsCalls(stub func(*promoter.Options) error) {
	fake.activateServiceAccountsMutex.Lock()
	defer fake.activateServiceAccountsMutex.Unlock()
	fake.ActivateServiceAccountsStub = stub
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsArgsForCall(i int) *promoter.Options {
	fake.activateServiceAccountsMutex.RLock()
	defer fake.activateServiceAccountsMutex.RUnlock()
	argsForCall := fake.activateServiceAccountsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsReturns(result1 error) {
	fake.activateServiceAccountsMutex.Lock()
	defer fake.activateServiceAccountsMutex.Unlock()
	fake.ActivateServiceAccountsStub = nil
	fake.activateServiceAccountsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsReturnsOnCall(i int, result1 error) {
	fake.activateServiceAccountsMutex.Lock()
	defer fake.activateServiceAccountsMutex.Unlock()
	fake.ActivateServiceAccountsStub = nil
	if fake.activateServiceAccountsReturnsOnCall == nil {
		fake.activateServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.activateServiceAccountsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshot(arg1 *promoter.Options, arg2 []inventory.Manifest) ([]inventory.Manifest, error) {
	var arg2Copy []inventory.Manifest
	if arg2 != nil {
		arg2Copy = make([]inventory.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.appendManifestToSnapshotMutex.Lock()
	ret, specificReturn := fake.appendManifestToSnapshotReturnsOnCall[len(fake.appendManifestToSnapshotArgsForCall)]
	fake.appendManifestToSnapshotArgsForCall = append(fake.appendManifestToSnapshotArgsForCall, struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}{arg1, arg2Copy})
	stub := fake.AppendManifestToSnapshotStub
	fakeReturns := fake.appendManifestToSnapshotReturns
	fake.recordInvocation("AppendManifestToSnapshot", []interface{}{arg1, arg2Copy})
	fake.appendManifestToSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotCallCount() int {
	fake.appendManifestToSnapshotMutex.RLock()
	defer fake.appendManifestToSnapshotMutex.RUnlock()
	return len(fake.appendManifestToSnapshotArgsForCall)
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotCalls(stub func(*promoter.Options, []inventory.Manifest) ([]inventory.Manifest, error)) {
	fake.appendManifestToSnapshotMutex.Lock()
	defer fake.appendManifestToSnapshotMutex.Unlock()
	fake.AppendManifestToSnapshotStub = stub
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotArgsForCall(i int) (*promoter.Options, []inventory.Manifest) {
	fake.appendManifestToSnapshotMutex.RLock()
	defer fake.appendManifestToSnapshotMutex.RUnlock()
	argsForCall := fake.appendManifestToSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotReturns(result1 []inventory.Manifest, result2 error) {
	fake.appendManifestToSnapshotMutex.Lock()
	defer fake.appendManifestToSnapshotMutex.Unlock()
	fake.AppendManifestToSnapshotStub = nil
	fake.appendManifestToSnapshotReturns = struct {
		result1 []inventory.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotReturnsOnCall(i int, result1 []inventory.Manifest, result2 error) {
	fake.appendManifestToSnapshotMutex.Lock()
	defer fake.appendManifestToSnapshotMutex.Unlock()
	fake.AppendManifestToSnapshotStub = nil
	if fake.appendManifestToSnapshotReturnsOnCall == nil {
		fake.appendManifestToSnapshotReturnsOnCall = make(map[int]struct {
			result1 []inventory.Manifest
			result2 error
		})
	}
	fake.appendManifestToSnapshotReturnsOnCall[i] = struct {
		result1 []inventory.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetPromotionEdges(arg1 *inventory.SyncContext, arg2 []inventory.Manifest) (map[inventory.PromotionEdge]interface{}, error) {
	var arg2Copy []inventory.Manifest
	if arg2 != nil {
		arg2Copy = make([]inventory.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getPromotionEdgesMutex.Lock()
	ret, specificReturn := fake.getPromotionEdgesReturnsOnCall[len(fake.getPromotionEdgesArgsForCall)]
	fake.getPromotionEdgesArgsForCall = append(fake.getPromotionEdgesArgsForCall, struct {
		arg1 *inventory.SyncContext
		arg2 []inventory.Manifest
	}{arg1, arg2Copy})
	stub := fake.GetPromotionEdgesStub
	fakeReturns := fake.getPromotionEdgesReturns
	fake.recordInvocation("GetPromotionEdges", []interface{}{arg1, arg2Copy})
	fake.getPromotionEdgesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetPromotionEdgesCallCount() int {
	fake.getPromotionEdgesMutex.RLock()
	defer fake.getPromotionEdgesMutex.RUnlock()
	return len(fake.getPromotionEdgesArgsForCall)
}

func (fake *FakePromoterImplementation) GetPromotionEdgesCalls(stub func(*inventory.SyncContext, []inventory.Manifest) (map[inventory.PromotionEdge]interface{}, error)) {
	fake.getPromotionEdgesMutex.Lock()
	defer fake.getPromotionEdgesMutex.Unlock()
	fake.GetPromotionEdgesStub = stub
}

func (fake *FakePromoterImplementation) GetPromotionEdgesArgsForCall(i int) (*inventory.SyncContext, []inventory.Manifest) {
	fake.getPromotionEdgesMutex.RLock()
	defer fake.getPromotionEdgesMutex.RUnlock()
	argsForCall := fake.getPromotionEdgesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) GetPromotionEdgesReturns(result1 map[inventory.PromotionEdge]interface{}, result2 error) {
	fake.getPromotionEdgesMutex.Lock()
	defer fake.getPromotionEdgesMutex.Unlock()
	fake.GetPromotionEdgesStub = nil
	fake.getPromotionEdgesReturns = struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetPromotionEdgesReturnsOnCall(i int, result1 map[inventory.PromotionEdge]interface{}, result2 error) {
	fake.getPromotionEdgesMutex.Lock()
	defer fake.getPromotionEdgesMutex.Unlock()
	fake.GetPromotionEdgesStub = nil
	if fake.getPromotionEdgesReturnsOnCall == nil {
		fake.getPromotionEdgesReturnsOnCall = make(map[int]struct {
			result1 map[inventory.PromotionEdge]interface{}
			result2 error
		})
	}
	fake.getPromotionEdgesReturnsOnCall[i] = struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetRegistryImageInventory(arg1 *promoter.Options, arg2 []inventory.Manifest) (inventory.RegInvImage, error) {
	var arg2Copy []inventory.Manifest
	if arg2 != nil {
		arg2Copy = make([]inventory.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getRegistryImageInventoryMutex.Lock()
	ret, specificReturn := fake.getRegistryImageInventoryReturnsOnCall[len(fake.getRegistryImageInventoryArgsForCall)]
	fake.getRegistryImageInventoryArgsForCall = append(fake.getRegistryImageInventoryArgsForCall, struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}{arg1, arg2Copy})
	stub := fake.GetRegistryImageInventoryStub
	fakeReturns := fake.getRegistryImageInventoryReturns
	fake.recordInvocation("GetRegistryImageInventory", []interface{}{arg1, arg2Copy})
	fake.getRegistryImageInventoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryCallCount() int {
	fake.getRegistryImageInventoryMutex.RLock()
	defer fake.getRegistryImageInventoryMutex.RUnlock()
	return len(fake.getRegistryImageInventoryArgsForCall)
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryCalls(stub func(*promoter.Options, []inventory.Manifest) (inventory.RegInvImage, error)) {
	fake.getRegistryImageInventoryMutex.Lock()
	defer fake.getRegistryImageInventoryMutex.Unlock()
	fake.GetRegistryImageInventoryStub = stub
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryArgsForCall(i int) (*promoter.Options, []inventory.Manifest) {
	fake.getRegistryImageInventoryMutex.RLock()
	defer fake.getRegistryImageInventoryMutex.RUnlock()
	argsForCall := fake.getRegistryImageInventoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryReturns(result1 inventory.RegInvImage, result2 error) {
	fake.getRegistryImageInventoryMutex.Lock()
	defer fake.getRegistryImageInventoryMutex.Unlock()
	fake.GetRegistryImageInventoryStub = nil
	fake.getRegistryImageInventoryReturns = struct {
		result1 inventory.RegInvImage
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryReturnsOnCall(i int, result1 inventory.RegInvImage, result2 error) {
	fake.getRegistryImageInventoryMutex.Lock()
	defer fake.getRegistryImageInventoryMutex.Unlock()
	fake.GetRegistryImageInventoryStub = nil
	if fake.getRegistryImageInventoryReturnsOnCall == nil {
		fake.getRegistryImageInventoryReturnsOnCall = make(map[int]struct {
			result1 inventory.RegInvImage
			result2 error
		})
	}
	fake.getRegistryImageInventoryReturnsOnCall[i] = struct {
		result1 inventory.RegInvImage
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotManifests(arg1 *promoter.Options) ([]inventory.Manifest, error) {
	fake.getSnapshotManifestsMutex.Lock()
	ret, specificReturn := fake.getSnapshotManifestsReturnsOnCall[len(fake.getSnapshotManifestsArgsForCall)]
	fake.getSnapshotManifestsArgsForCall = append(fake.getSnapshotManifestsArgsForCall, struct {
		arg1 *promoter.Options
	}{arg1})
	stub := fake.GetSnapshotManifestsStub
	fakeReturns := fake.getSnapshotManifestsReturns
	fake.recordInvocation("GetSnapshotManifests", []interface{}{arg1})
	fake.getSnapshotManifestsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsCallCount() int {
	fake.getSnapshotManifestsMutex.RLock()
	defer fake.getSnapshotManifestsMutex.RUnlock()
	return len(fake.getSnapshotManifestsArgsForCall)
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsCalls(stub func(*promoter.Options) ([]inventory.Manifest, error)) {
	fake.getSnapshotManifestsMutex.Lock()
	defer fake.getSnapshotManifestsMutex.Unlock()
	fake.GetSnapshotManifestsStub = stub
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsArgsForCall(i int) *promoter.Options {
	fake.getSnapshotManifestsMutex.RLock()
	defer fake.getSnapshotManifestsMutex.RUnlock()
	argsForCall := fake.getSnapshotManifestsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsReturns(result1 []inventory.Manifest, result2 error) {
	fake.getSnapshotManifestsMutex.Lock()
	defer fake.getSnapshotManifestsMutex.Unlock()
	fake.GetSnapshotManifestsStub = nil
	fake.getSnapshotManifestsReturns = struct {
		result1 []inventory.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsReturnsOnCall(i int, result1 []inventory.Manifest, result2 error) {
	fake.getSnapshotManifestsMutex.Lock()
	defer fake.getSnapshotManifestsMutex.Unlock()
	fake.GetSnapshotManifestsStub = nil
	if fake.getSnapshotManifestsReturnsOnCall == nil {
		fake.getSnapshotManifestsReturnsOnCall = make(map[int]struct {
			result1 []inventory.Manifest
			result2 error
		})
	}
	fake.getSnapshotManifestsReturnsOnCall[i] = struct {
		result1 []inventory.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistry(arg1 *promoter.Options) (*inventory.RegistryContext, error) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	ret, specificReturn := fake.getSnapshotSourceRegistryReturnsOnCall[len(fake.getSnapshotSourceRegistryArgsForCall)]
	fake.getSnapshotSourceRegistryArgsForCall = append(fake.getSnapshotSourceRegistryArgsForCall, struct {
		arg1 *promoter.Options
	}{arg1})
	stub := fake.GetSnapshotSourceRegistryStub
	fakeReturns := fake.getSnapshotSourceRegistryReturns
	fake.recordInvocation("GetSnapshotSourceRegistry", []interface{}{arg1})
	fake.getSnapshotSourceRegistryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryCallCount() int {
	fake.getSnapshotSourceRegistryMutex.RLock()
	defer fake.getSnapshotSourceRegistryMutex.RUnlock()
	return len(fake.getSnapshotSourceRegistryArgsForCall)
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryCalls(stub func(*promoter.Options) (*inventory.RegistryContext, error)) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	defer fake.getSnapshotSourceRegistryMutex.Unlock()
	fake.GetSnapshotSourceRegistryStub = stub
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryArgsForCall(i int) *promoter.Options {
	fake.getSnapshotSourceRegistryMutex.RLock()
	defer fake.getSnapshotSourceRegistryMutex.RUnlock()
	argsForCall := fake.getSnapshotSourceRegistryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryReturns(result1 *inventory.RegistryContext, result2 error) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	defer fake.getSnapshotSourceRegistryMutex.Unlock()
	fake.GetSnapshotSourceRegistryStub = nil
	fake.getSnapshotSourceRegistryReturns = struct {
		result1 *inventory.RegistryContext
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryReturnsOnCall(i int, result1 *inventory.RegistryContext, result2 error) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	defer fake.getSnapshotSourceRegistryMutex.Unlock()
	fake.GetSnapshotSourceRegistryStub = nil
	if fake.getSnapshotSourceRegistryReturnsOnCall == nil {
		fake.getSnapshotSourceRegistryReturnsOnCall = make(map[int]struct {
			result1 *inventory.RegistryContext
			result2 error
		})
	}
	fake.getSnapshotSourceRegistryReturnsOnCall[i] = struct {
		result1 *inventory.RegistryContext
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) MakeProducerFunction(arg1 bool) promoter.StreamProducerFunc {
	fake.makeProducerFunctionMutex.Lock()
	ret, specificReturn := fake.makeProducerFunctionReturnsOnCall[len(fake.makeProducerFunctionArgsForCall)]
	fake.makeProducerFunctionArgsForCall = append(fake.makeProducerFunctionArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.MakeProducerFunctionStub
	fakeReturns := fake.makeProducerFunctionReturns
	fake.recordInvocation("MakeProducerFunction", []interface{}{arg1})
	fake.makeProducerFunctionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) MakeProducerFunctionCallCount() int {
	fake.makeProducerFunctionMutex.RLock()
	defer fake.makeProducerFunctionMutex.RUnlock()
	return len(fake.makeProducerFunctionArgsForCall)
}

func (fake *FakePromoterImplementation) MakeProducerFunctionCalls(stub func(bool) promoter.StreamProducerFunc) {
	fake.makeProducerFunctionMutex.Lock()
	defer fake.makeProducerFunctionMutex.Unlock()
	fake.MakeProducerFunctionStub = stub
}

func (fake *FakePromoterImplementation) MakeProducerFunctionArgsForCall(i int) bool {
	fake.makeProducerFunctionMutex.RLock()
	defer fake.makeProducerFunctionMutex.RUnlock()
	argsForCall := fake.makeProducerFunctionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) MakeProducerFunctionReturns(result1 promoter.StreamProducerFunc) {
	fake.makeProducerFunctionMutex.Lock()
	defer fake.makeProducerFunctionMutex.Unlock()
	fake.MakeProducerFunctionStub = nil
	fake.makeProducerFunctionReturns = struct {
		result1 promoter.StreamProducerFunc
	}{result1}
}

func (fake *FakePromoterImplementation) MakeProducerFunctionReturnsOnCall(i int, result1 promoter.StreamProducerFunc) {
	fake.makeProducerFunctionMutex.Lock()
	defer fake.makeProducerFunctionMutex.Unlock()
	fake.MakeProducerFunctionStub = nil
	if fake.makeProducerFunctionReturnsOnCall == nil {
		fake.makeProducerFunctionReturnsOnCall = make(map[int]struct {
			result1 promoter.StreamProducerFunc
		})
	}
	fake.makeProducerFunctionReturnsOnCall[i] = struct {
		result1 promoter.StreamProducerFunc
	}{result1}
}

func (fake *FakePromoterImplementation) MakeSyncContext(arg1 *promoter.Options, arg2 []inventory.Manifest) (*inventory.SyncContext, error) {
	var arg2Copy []inventory.Manifest
	if arg2 != nil {
		arg2Copy = make([]inventory.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.makeSyncContextMutex.Lock()
	ret, specificReturn := fake.makeSyncContextReturnsOnCall[len(fake.makeSyncContextArgsForCall)]
	fake.makeSyncContextArgsForCall = append(fake.makeSyncContextArgsForCall, struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}{arg1, arg2Copy})
	stub := fake.MakeSyncContextStub
	fakeReturns := fake.makeSyncContextReturns
	fake.recordInvocation("MakeSyncContext", []interface{}{arg1, arg2Copy})
	fake.makeSyncContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) MakeSyncContextCallCount() int {
	fake.makeSyncContextMutex.RLock()
	defer fake.makeSyncContextMutex.RUnlock()
	return len(fake.makeSyncContextArgsForCall)
}

func (fake *FakePromoterImplementation) MakeSyncContextCalls(stub func(*promoter.Options, []inventory.Manifest) (*inventory.SyncContext, error)) {
	fake.makeSyncContextMutex.Lock()
	defer fake.makeSyncContextMutex.Unlock()
	fake.MakeSyncContextStub = stub
}

func (fake *FakePromoterImplementation) MakeSyncContextArgsForCall(i int) (*promoter.Options, []inventory.Manifest) {
	fake.makeSyncContextMutex.RLock()
	defer fake.makeSyncContextMutex.RUnlock()
	argsForCall := fake.makeSyncContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) MakeSyncContextReturns(result1 *inventory.SyncContext, result2 error) {
	fake.makeSyncContextMutex.Lock()
	defer fake.makeSyncContextMutex.Unlock()
	fake.MakeSyncContextStub = nil
	fake.makeSyncContextReturns = struct {
		result1 *inventory.SyncContext
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) MakeSyncContextReturnsOnCall(i int, result1 *inventory.SyncContext, result2 error) {
	fake.makeSyncContextMutex.Lock()
	defer fake.makeSyncContextMutex.Unlock()
	fake.MakeSyncContextStub = nil
	if fake.makeSyncContextReturnsOnCall == nil {
		fake.makeSyncContextReturnsOnCall = make(map[int]struct {
			result1 *inventory.SyncContext
			result2 error
		})
	}
	fake.makeSyncContextReturnsOnCall[i] = struct {
		result1 *inventory.SyncContext
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) ParseManifests(arg1 *promoter.Options) ([]inventory.Manifest, error) {
	fake.parseManifestsMutex.Lock()
	ret, specificReturn := fake.parseManifestsReturnsOnCall[len(fake.parseManifestsArgsForCall)]
	fake.parseManifestsArgsForCall = append(fake.parseManifestsArgsForCall, struct {
		arg1 *promoter.Options
	}{arg1})
	stub := fake.ParseManifestsStub
	fakeReturns := fake.parseManifestsReturns
	fake.recordInvocation("ParseManifests", []interface{}{arg1})
	fake.parseManifestsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) ParseManifestsCallCount() int {
	fake.parseManifestsMutex.RLock()
	defer fake.parseManifestsMutex.RUnlock()
	return len(fake.parseManifestsArgsForCall)
}

func (fake *FakePromoterImplementation) ParseManifestsCalls(stub func(*promoter.Options) ([]inventory.Manifest, error)) {
	fake.parseManifestsMutex.Lock()
	defer fake.parseManifestsMutex.Unlock()
	fake.ParseManifestsStub = stub
}

func (fake *FakePromoterImplementation) ParseManifestsArgsForCall(i int) *promoter.Options {
	fake.parseManifestsMutex.RLock()
	defer fake.parseManifestsMutex.RUnlock()
	argsForCall := fake.parseManifestsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ParseManifestsReturns(result1 []inventory.Manifest, result2 error) {
	fake.parseManifestsMutex.Lock()
	defer fake.parseManifestsMutex.Unlock()
	fake.ParseManifestsStub = nil
	fake.parseManifestsReturns = struct {
		result1 []inventory.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) ParseManifestsReturnsOnCall(i int, result1 []inventory.Manifest, result2 error) {
	fake.parseManifestsMutex.Lock()
	defer fake.parseManifestsMutex.Unlock()
	fake.ParseManifestsStub = nil
	if fake.parseManifestsReturnsOnCall == nil {
		fake.parseManifestsReturnsOnCall = make(map[int]struct {
			result1 []inventory.Manifest
			result2 error
		})
	}
	fake.parseManifestsReturnsOnCall[i] = struct {
		result1 []inventory.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) PrecheckAndExit(arg1 *promoter.Options, arg2 []inventory.Manifest) error {
	var arg2Copy []inventory.Manifest
	if arg2 != nil {
		arg2Copy = make([]inventory.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.precheckAndExitMutex.Lock()
	ret, specificReturn := fake.precheckAndExitReturnsOnCall[len(fake.precheckAndExitArgsForCall)]
	fake.precheckAndExitArgsForCall = append(fake.precheckAndExitArgsForCall, struct {
		arg1 *promoter.Options
		arg2 []inventory.Manifest
	}{arg1, arg2Copy})
	stub := fake.PrecheckAndExitStub
	fakeReturns := fake.precheckAndExitReturns
	fake.recordInvocation("PrecheckAndExit", []interface{}{arg1, arg2Copy})
	fake.precheckAndExitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) PrecheckAndExitCallCount() int {
	fake.precheckAndExitMutex.RLock()
	defer fake.precheckAndExitMutex.RUnlock()
	return len(fake.precheckAndExitArgsForCall)
}

func (fake *FakePromoterImplementation) PrecheckAndExitCalls(stub func(*promoter.Options, []inventory.Manifest) error) {
	fake.precheckAndExitMutex.Lock()
	defer fake.precheckAndExitMutex.Unlock()
	fake.PrecheckAndExitStub = stub
}

func (fake *FakePromoterImplementation) PrecheckAndExitArgsForCall(i int) (*promoter.Options, []inventory.Manifest) {
	fake.precheckAndExitMutex.RLock()
	defer fake.precheckAndExitMutex.RUnlock()
	argsForCall := fake.precheckAndExitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) PrecheckAndExitReturns(result1 error) {
	fake.precheckAndExitMutex.Lock()
	defer fake.precheckAndExitMutex.Unlock()
	fake.PrecheckAndExitStub = nil
	fake.precheckAndExitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PrecheckAndExitReturnsOnCall(i int, result1 error) {
	fake.precheckAndExitMutex.Lock()
	defer fake.precheckAndExitMutex.Unlock()
	fake.PrecheckAndExitStub = nil
	if fake.precheckAndExitReturnsOnCall == nil {
		fake.precheckAndExitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.precheckAndExitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PromoteImages(arg1 *inventory.SyncContext, arg2 map[inventory.PromotionEdge]interface{}, arg3 promoter.StreamProducerFunc) error {
	fake.promoteImagesMutex.Lock()
	ret, specificReturn := fake.promoteImagesReturnsOnCall[len(fake.promoteImagesArgsForCall)]
	fake.promoteImagesArgsForCall = append(fake.promoteImagesArgsForCall, struct {
		arg1 *inventory.SyncContext
		arg2 map[inventory.PromotionEdge]interface{}
		arg3 promoter.StreamProducerFunc
	}{arg1, arg2, arg3})
	stub := fake.PromoteImagesStub
	fakeReturns := fake.promoteImagesReturns
	fake.recordInvocation("PromoteImages", []interface{}{arg1, arg2, arg3})
	fake.promoteImagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) PromoteImagesCallCount() int {
	fake.promoteImagesMutex.RLock()
	defer fake.promoteImagesMutex.RUnlock()
	return len(fake.promoteImagesArgsForCall)
}

func (fake *FakePromoterImplementation) PromoteImagesCalls(stub func(*inventory.SyncContext, map[inventory.PromotionEdge]interface{}, promoter.StreamProducerFunc) error) {
	fake.promoteImagesMutex.Lock()
	defer fake.promoteImagesMutex.Unlock()
	fake.PromoteImagesStub = stub
}

func (fake *FakePromoterImplementation) PromoteImagesArgsForCall(i int) (*inventory.SyncContext, map[inventory.PromotionEdge]interface{}, promoter.StreamProducerFunc) {
	fake.promoteImagesMutex.RLock()
	defer fake.promoteImagesMutex.RUnlock()
	argsForCall := fake.promoteImagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) PromoteImagesReturns(result1 error) {
	fake.promoteImagesMutex.Lock()
	defer fake.promoteImagesMutex.Unlock()
	fake.PromoteImagesStub = nil
	fake.promoteImagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PromoteImagesReturnsOnCall(i int, result1 error) {
	fake.promoteImagesMutex.Lock()
	defer fake.promoteImagesMutex.Unlock()
	fake.PromoteImagesStub = nil
	if fake.promoteImagesReturnsOnCall == nil {
		fake.promoteImagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.promoteImagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ScanEdges(arg1 *promoter.Options, arg2 *inventory.SyncContext, arg3 map[inventory.PromotionEdge]interface{}) error {
	fake.scanEdgesMutex.Lock()
	ret, specificReturn := fake.scanEdgesReturnsOnCall[len(fake.scanEdgesArgsForCall)]
	fake.scanEdgesArgsForCall = append(fake.scanEdgesArgsForCall, struct {
		arg1 *promoter.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}{arg1, arg2, arg3})
	stub := fake.ScanEdgesStub
	fakeReturns := fake.scanEdgesReturns
	fake.recordInvocation("ScanEdges", []interface{}{arg1, arg2, arg3})
	fake.scanEdgesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ScanEdgesCallCount() int {
	fake.scanEdgesMutex.RLock()
	defer fake.scanEdgesMutex.RUnlock()
	return len(fake.scanEdgesArgsForCall)
}

func (fake *FakePromoterImplementation) ScanEdgesCalls(stub func(*promoter.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error) {
	fake.scanEdgesMutex.Lock()
	defer fake.scanEdgesMutex.Unlock()
	fake.ScanEdgesStub = stub
}

func (fake *FakePromoterImplementation) ScanEdgesArgsForCall(i int) (*promoter.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) {
	fake.scanEdgesMutex.RLock()
	defer fake.scanEdgesMutex.RUnlock()
	argsForCall := fake.scanEdgesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) ScanEdgesReturns(result1 error) {
	fake.scanEdgesMutex.Lock()
	defer fake.scanEdgesMutex.Unlock()
	fake.ScanEdgesStub = nil
	fake.scanEdgesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ScanEdgesReturnsOnCall(i int, result1 error) {
	fake.scanEdgesMutex.Lock()
	defer fake.scanEdgesMutex.Unlock()
	fake.ScanEdgesStub = nil
	if fake.scanEdgesReturnsOnCall == nil {
		fake.scanEdgesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanEdgesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) Snapshot(arg1 *promoter.Options, arg2 inventory.RegInvImage) error {
	fake.snapshotMutex.Lock()
	ret, specificReturn := fake.snapshotReturnsOnCall[len(fake.snapshotArgsForCall)]
	fake.snapshotArgsForCall = append(fake.snapshotArgsForCall, struct {
		arg1 *promoter.Options
		arg2 inventory.RegInvImage
	}{arg1, arg2})
	stub := fake.SnapshotStub
	fakeReturns := fake.snapshotReturns
	fake.recordInvocation("Snapshot", []interface{}{arg1, arg2})
	fake.snapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) SnapshotCallCount() int {
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	return len(fake.snapshotArgsForCall)
}

func (fake *FakePromoterImplementation) SnapshotCalls(stub func(*promoter.Options, inventory.RegInvImage) error) {
	fake.snapshotMutex.Lock()
	defer fake.snapshotMutex.Unlock()
	fake.SnapshotStub = stub
}

func (fake *FakePromoterImplementation) SnapshotArgsForCall(i int) (*promoter.Options, inventory.RegInvImage) {
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	argsForCall := fake.snapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) SnapshotReturns(result1 error) {
	fake.snapshotMutex.Lock()
	defer fake.snapshotMutex.Unlock()
	fake.SnapshotStub = nil
	fake.snapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) SnapshotReturnsOnCall(i int, result1 error) {
	fake.snapshotMutex.Lock()
	defer fake.snapshotMutex.Unlock()
	fake.SnapshotStub = nil
	if fake.snapshotReturnsOnCall == nil {
		fake.snapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.snapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateManifestLists(arg1 *promoter.Options) error {
	fake.validateManifestListsMutex.Lock()
	ret, specificReturn := fake.validateManifestListsReturnsOnCall[len(fake.validateManifestListsArgsForCall)]
	fake.validateManifestListsArgsForCall = append(fake.validateManifestListsArgsForCall, struct {
		arg1 *promoter.Options
	}{arg1})
	stub := fake.ValidateManifestListsStub
	fakeReturns := fake.validateManifestListsReturns
	fake.recordInvocation("ValidateManifestLists", []interface{}{arg1})
	fake.validateManifestListsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ValidateManifestListsCallCount() int {
	fake.validateManifestListsMutex.RLock()
	defer fake.validateManifestListsMutex.RUnlock()
	return len(fake.validateManifestListsArgsForCall)
}

func (fake *FakePromoterImplementation) ValidateManifestListsCalls(stub func(*promoter.Options) error) {
	fake.validateManifestListsMutex.Lock()
	defer fake.validateManifestListsMutex.Unlock()
	fake.ValidateManifestListsStub = stub
}

func (fake *FakePromoterImplementation) ValidateManifestListsArgsForCall(i int) *promoter.Options {
	fake.validateManifestListsMutex.RLock()
	defer fake.validateManifestListsMutex.RUnlock()
	argsForCall := fake.validateManifestListsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ValidateManifestListsReturns(result1 error) {
	fake.validateManifestListsMutex.Lock()
	defer fake.validateManifestListsMutex.Unlock()
	fake.ValidateManifestListsStub = nil
	fake.validateManifestListsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateManifestListsReturnsOnCall(i int, result1 error) {
	fake.validateManifestListsMutex.Lock()
	defer fake.validateManifestListsMutex.Unlock()
	fake.ValidateManifestListsStub = nil
	if fake.validateManifestListsReturnsOnCall == nil {
		fake.validateManifestListsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateManifestListsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateOptions(arg1 *promoter.Options) error {
	fake.validateOptionsMutex.Lock()
	ret, specificReturn := fake.validateOptionsReturnsOnCall[len(fake.validateOptionsArgsForCall)]
	fake.validateOptionsArgsForCall = append(fake.validateOptionsArgsForCall, struct {
		arg1 *promoter.Options
	}{arg1})
	stub := fake.ValidateOptionsStub
	fakeReturns := fake.validateOptionsReturns
	fake.recordInvocation("ValidateOptions", []interface{}{arg1})
	fake.validateOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ValidateOptionsCallCount() int {
	fake.validateOptionsMutex.RLock()
	defer fake.validateOptionsMutex.RUnlock()
	return len(fake.validateOptionsArgsForCall)
}

func (fake *FakePromoterImplementation) ValidateOptionsCalls(stub func(*promoter.Options) error) {
	fake.validateOptionsMutex.Lock()
	defer fake.validateOptionsMutex.Unlock()
	fake.ValidateOptionsStub = stub
}

func (fake *FakePromoterImplementation) ValidateOptionsArgsForCall(i int) *promoter.Options {
	fake.validateOptionsMutex.RLock()
	defer fake.validateOptionsMutex.RUnlock()
	argsForCall := fake.validateOptionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ValidateOptionsReturns(result1 error) {
	fake.validateOptionsMutex.Lock()
	defer fake.validateOptionsMutex.Unlock()
	fake.ValidateOptionsStub = nil
	fake.validateOptionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateOptionsReturnsOnCall(i int, result1 error) {
	fake.validateOptionsMutex.Lock()
	defer fake.validateOptionsMutex.Unlock()
	fake.ValidateOptionsStub = nil
	if fake.validateOptionsReturnsOnCall == nil {
		fake.validateOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activateServiceAccountsMutex.RLock()
	defer fake.activateServiceAccountsMutex.RUnlock()
	fake.appendManifestToSnapshotMutex.RLock()
	defer fake.appendManifestToSnapshotMutex.RUnlock()
	fake.getPromotionEdgesMutex.RLock()
	defer fake.getPromotionEdgesMutex.RUnlock()
	fake.getRegistryImageInventoryMutex.RLock()
	defer fake.getRegistryImageInventoryMutex.RUnlock()
	fake.getSnapshotManifestsMutex.RLock()
	defer fake.getSnapshotManifestsMutex.RUnlock()
	fake.getSnapshotSourceRegistryMutex.RLock()
	defer fake.getSnapshotSourceRegistryMutex.RUnlock()
	fake.makeProducerFunctionMutex.RLock()
	defer fake.makeProducerFunctionMutex.RUnlock()
	fake.makeSyncContextMutex.RLock()
	defer fake.makeSyncContextMutex.RUnlock()
	fake.parseManifestsMutex.RLock()
	defer fake.parseManifestsMutex.RUnlock()
	fake.precheckAndExitMutex.RLock()
	defer fake.precheckAndExitMutex.RUnlock()
	fake.promoteImagesMutex.RLock()
	defer fake.promoteImagesMutex.RUnlock()
	fake.scanEdgesMutex.RLock()
	defer fake.scanEdgesMutex.RUnlock()
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	fake.validateManifestListsMutex.RLock()
	defer fake.validateManifestListsMutex.RUnlock()
	fake.validateOptionsMutex.RLock()
	defer fake.validateOptionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePromoterImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
